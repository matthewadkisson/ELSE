/*
 *  Copyright (C) 2015 Larry Morell <morell@cs.atu.edu>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package language;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Buffer implements a buff which can be read from in various ways. Abstract
 * model: buff is a sequence of characters Current position is a position
 * within, or beyond the buff Current character is the character from the buff
 * referenced by the current position, if such a one exists. If it does not then
 * the the current character is the null character.
 *
 * @author Larry Morell <lmorell@atu.edu>
 */
public class Buffer {

    // ----------------- Class-wide functions ----------------- //
    // These implement several functions that are also implemented in Character
    // These assume that the characters are all ASCII and are therefore simplified
    // accordingly, and (hopefully) will reduce runtime overhead when doing these
    // simple tests.  This may not actuall be true since I don't know how the
    // comparison operators are implemented.   The aim here is to eliminate the
    // number of function calls that are generated by calling Character.isDigit(),
    // e.g., we have (at least) five function calls.    A simple test revealed
    // that isDigit() implemented as below took half the time.  However, calling
    // any of these functions, about 10K times (a very large algorithm), would be negligible overhead
    // of 10**-5 seconds, so this realling is not a big deal.
	/*
     public static boolean isAlphaNum(char ch) {
     /*
     if (ch >= 'A' && ch <= 'Z') {
     return true;
     }
     if (ch >= 'a' && ch <= 'z') {
     return true;
     }
     if (ch >= '0' && ch <= '9') {
     return true;
     }
     return false;

     return Character.isLetterOrDigit(ch);
     }

     static boolean isDigit(char ch) {
     // return (ch >= '0' && ch <= '9');
     return Character.isDigit(ch);
     }

     public static boolean isWhiteSpace(char ch) {
     // return (ch == ' ') || (ch == '\n') || (ch == '\t') || (ch == '\r');
     return Character.isWhitespace(ch);
     }
     */
    static boolean errorOnEOF = false;

    public static void setErrorOnEofAccess() {
        errorOnEOF = true;
    }
    // --------------- Instance variables --------------- //
    protected String buffer;   // the buff to be accessed
    protected String fileName; // the source file name
    protected int pos;           // position within the buff (0-based)
    protected int lineNo;     // the line within the buff (1-based)
    protected int colPos;      // the position within a line (1-based)

    //---------------- Constructors ---------------------//
    public Buffer() {
        this("");
    }

    /**
     *
     * @param string -- the string from which data is to be read
     */
    public Buffer(String string) {
        buffer = string;
        pos = 0;
        colPos = 1; // past end of line
        lineNo = 1; // past end of file
        fileName = "Source string";
    }

    /**
     * Constructor to assign
     *
     * @param in -- the source file
     */
    public Buffer(FileReader in, String fileName) {
        this("");
        StringBuilder buff = new StringBuilder();
        this.fileName = fileName;
        int count;
        char buf[] = new char[512];
        int offset = 0;
        try {
            while ((count = in.read(buf, offset, 512)) >= 0) {
                buff.append(buf, offset, count);
            }
        } catch (IOException ex) {
            Logger.getLogger(Buffer.class.getName()).log(Level.SEVERE, null, ex);
        }
        this.buffer = new String(buff);
    }

    /**
     * Copy constructor
     *
     * @param buff -- the buff to be copied
     */
    public Buffer(Buffer buffer) {
        this.buffer = buffer.buffer;
        pos = buffer.pos;
        lineNo = buffer.lineNo;
        colPos = buffer.colPos;
        fileName = buffer.fileName;
    }

    /**
     * Override this to allow copying a Buffer
     *
     * @param b -- create a new instance of b
     * @return
     */
    public static Buffer newInstance(Buffer b) {
        return new Buffer(b);
    }

    // ----------------- Getters/Setters --------------------//
    /**
     * @return The buff currently in use.
     *
     */
    public String getBuffer() {
        return buffer;
    }

    /**
     * If the current position references a point in the current buff then
     * return the character at that position; otherwise return the null
     * character.
     */
    public char charAt(int i) {
        if (i < 0 || i > buffer.length()) {
            return ('\0');  // return the null character
        }
        return buffer.charAt(i);  // Fake out the compiler
    }

    /**
     * Return the number of characters in the buff
     *
     * @return the length of the buffer
     */
    public int size() {
        return buffer.length();
    }

    /**
     * @return If the current position is within the buff bounds, return that
     * position; otherwise return the length of the buff.
     */
    public int getPos() {
        return pos;
    }

    public void setPos(int n) {
        pos = n;
    }

    /**
     * @return If the current position is with the bounds of the buff, return
     * false, otherwise, return true
     */
    public boolean eof() {
        return (pos >= buffer.length());
    }

    /**
     * @return
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Return</b> </td>
     * </tr>
     * <tr>
     * <td>Current position within the buff and the current char is a \n or
     * \r</td>
     * <td>true </td>
     * </tr>
     * <tr>
     * <td> Otherwise</td>
     * <td> false</td>
     * </tr>
     * </table>
     */
    public boolean eoln() {
        return pos >= buffer.length() || buffer.charAt(pos) == '\n'
            || buffer.charAt(pos) == '\r';
    }

    /**
     * @return
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Return</b> </td>
     * <td> <b>Side effects</b></td>
     * </tr>
     * <tr>
     * <td>Current position is within the buff</td>
     * <td>The associated char</td>
     * <td>Increments the current position in the buff</td>
     * </tr>
     * <tr>
     * <td>errorOnEof is set</td>
     * <td>Nothing</td>
     * <td>Error message  </td>
     * </tr>
     * <tr>
     * <td>errorOnEof is not set (default</td>
     * <td>null char</td>
     * <td></td>
     * </tr>
     *
     * </table>
     */
    public char get() {

        if (pos < 0 || pos >= buffer.length()) {
            if (errorOnEOF) {
                System.err.println("Attempt to read past end of buffer at position" + pos);
                System.exit(-1);
            } else {
                return '\0';
            }
        }

        if (buffer.charAt(pos) == '\n') {
            lineNo++;
            colPos = 1;
        } else {
            colPos++;
        }
        pos++;
        return buffer.charAt(pos - 1);  // return the char just advanced past
    }

    /**
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Behavior</b> </td>
     * </tr>
     * <tr>
     * <td>Current position is within the buff</td>
     * <td>Current position is one greater</td>
     * </tr>
     * <tr>
     * <td>Current position is not with the buff</td>
     * <td>Current position is unchanged</td>
     * </tr>
     * </table>
     */
    public void advance() {
        if (pos >= 0 && pos < buffer.length()) {
            pos++;
            if (buffer.charAt(pos - 1) == '\n') {
                lineNo++;
                colPos = 1;
            } else {
                colPos++;
            }
        }
    }

    public void backup() {
        if (pos > 0 && pos < buffer.length()) {
            pos--;
            if (buffer.charAt(pos) == '\n') {
                lineNo--;
                int p = pos;
                while (p >= 0 && buffer.charAt(pos) != '\n') {
                    p--;
                }
                colPos = pos - p -1;
            }
        }
    }

    /**
     * @return
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Return</b> </td>
     * </tr>
     * <tr>
     * <td>Current position is within the buff</td>
     * <td>The char at that position</td>
     * </tr>
     * <tr>
     * <td>Otherwise</td>
     * <td>Nothing</td>
     * <td>Error message</td>
     * </tr>
     * </table>
     */
    public char peek() {
        if (pos < 0 || pos >= buffer.length()) {
            return '\0';  // Return null character if off the end
        }

        return buffer.charAt(pos);  // return next char get returns
    }

    public char peek(int n) {
        pos += n;
        char ch = peek();
        pos -= n;
        return ch;
    }

    @SuppressWarnings("empty-statement")
    public void skipBlanks() {

        while (!eof() && Character.isWhitespace(buffer.charAt(pos))) {
            advance();
        }
    }

    /**
     * @return
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Return</b> </td>
     * <td> <b>Side effects </b> </td>
     * </tr>
     * <tr>
     * <td>Whitespace*No occurs next in the buff</td>
     * <td>No</td>
     * <td>Current position is immediately after No</td>
     * </tr>
     * <tr>
     * <td>Otherwise</td>
     * <td>""</td>
     * </tr>
     * </table>
     */
    public String getNumber() {
        StringBuilder sb = new StringBuilder();
        skipBlanks();
        while (pos < buffer.length() && buffer.charAt(pos) >= '0' && buffer.charAt(pos) <= '9') {
            sb.append(get());
        }

        if (!eof() && buffer.charAt(pos) == '.') {
            sb.append('.');
            advance();
            while (pos < buffer.length() && buffer.charAt(pos) >= '0' && buffer.charAt(pos) <= '9') {
                sb.append(get());
            }
        }
        return new String(sb);
    }

    public String getId() {
        StringBuilder sb = new StringBuilder();
        skipBlanks();
        if (!eof() && Character.isLetter(buffer.charAt(pos))) {
            while (!eof() && Character.isLetterOrDigit(buffer.charAt(pos))) {
                sb.append(buffer.charAt(pos));
                advance();
            }
        }
        return new String(sb);
    }

    /**
     * An Operator is any sequence of characters that begin with none of
     * (whitespace, digit, or letter) and terminates at the first (whitespace,
     * digit, or letter) or eof(), whichever occurs first.
     *
     * @return
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Return</b> </td>
     * <td> <b>Side effects </b> </td>
     * </tr>
     * <tr>
     * <td>Whitespace*Operator appears next in buff</td>
     * <td>Operator</td>
     * <td>Current position follows after Operator</td>
     * </tr>
     * <tr>
     * <td>Otherwise</td>
     * <td>None</td>
     * <td>Error message</td>
     * </tr>
     * </table>
     */
    public String getOperator() {
        StringBuilder sb = new StringBuilder();
        skipBlanks();
        String singletons = "()[],;";
        while (!eof()
            && !Character.isWhitespace(buffer.charAt(pos))
            && !Character.isLetterOrDigit(buffer.charAt(pos))
            && !singletons.contains("" + buffer.charAt(pos))) {
            sb.append(get());
        }
        if (!eof()
            && sb.length() == 0
            && singletons.contains("" + buffer.charAt(pos))) {
            sb.append(get());
        }
        return new String(sb);
    }

    /**
     * @return
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Return</b> </td>
     * <td> <b>Side effects </b> </td>
     * </tr>
     * <tr>
     * <td>Current position within buff</td>
     * <td>The sequence of characters from the current position up to, but not
     * including, the next end-of-line, or end-of-file, whichever occurs
     * first</td>
     * <td>Current position is set after the termination point </td>
     * </tr>
     * <tr>
     * <td>Otherwise</td>
     * <td>""</td>
     * <td>Current position is set outside the buff</td>
     * </tr>
     * </table>
     */
    public String getToEoln() {
        StringBuilder sb = new StringBuilder();
        while (!eof() && !eoln()) {
            sb.append(get());
        }
        advance();
        return new String(sb);
    }

    /**
     * @return
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Return</b> </td>
     * </tr>
     * <tr>
     * <td>There is a character in the buff after the current pos</td>
     * <td>That character</td>
     * </tr>
     * <tr>
     * <td>Otherwise</td>
     * <td>Null character</td>
     * </tr>
     * </table>
     */
    public char nextChar() {
        if (eof() || pos == buffer.length() - 1) {
            return '\0';
        }
        return buffer.charAt(pos + 1);
    }

    /**
     * @return
     * <table>
     * <tr>
     * <td><b>Condition</b> </td>
     * <td> <b>Return</b> </td>
     * <td> <b>Side effects </b> </td>
     * </tr>
     * <tr>
     * <td>delim occurs in the buff at or after the current position</td>
     * <td>the sequence of characters to to that delimeter</td>
     * <td>Current position is placed after delim</td>
     * </tr>
     * <tr>
     * <td>Otherwise</td>
     * <td></td>
     * <td>Error message</td>
     * </tr>
     * </table>
     */
    public String getToDelimiter(String delim) {

        StringBuilder sb = new StringBuilder();
        int endPos = buffer.indexOf(delim, pos);
        if (endPos >= buffer.length()) {
            System.err.println("Error, attempting to find " + delim + "; it was not found.");
        }
        // Slow append one char at at time so line and character positioning
        // will be done by get()
        for (int i = pos; i < endPos; i++) {
            sb.append(get());
        }
        for (int i = 0; i < delim.length() - 1; i++) {
            advance();  // skip delim
        }
        advance();
        // System.err.println("gotodelim returns '" + sb + "'");
        return new String(sb);
    }

    public void setSource(String s) {
        buffer = s;
        pos = 0;
        colPos = 1; // past end of line
        lineNo = 1; // past end of file
        fileName = "String source";
    }

    public void setSource(FileReader in, String fileName) {
        this.fileName = fileName;
        StringBuilder b = new StringBuilder();
        int count;
        char buf[] = new char[512];
        int offset = 0;
        try {
            while ((count = in.read(buf, offset, 512)) >= 0) {
                b.append(buf, offset, count);
            }
            buffer = new String(b);
        } catch (IOException ex) {
            Logger.getLogger(Buffer.class.getName()).log(Level.SEVERE, null, ex);
        }
        pos = 0;
        colPos = 1; // past end of line
        lineNo = 1; // past end of file
    }

    public int lineNumber() {
        return lineNo;
    }

    public int columnNumber() {
        return colPos;
    }

    public String getFileName() {
        return fileName;
    }

    public static void check(boolean b, String msg) {
        if (!b) {
            System.err.println(msg + ": failed!");
        }
        //else
        //System.err.println(msg + ": succeeded");
    }

    public static void main(String[] args) {
        // test to see how buffers work
        // Check an empty buff
        Buffer b = new Buffer("");
        check(b.eoln(), "eoln for an empty buffer should be true");
        check(b.eof(), "eof for an empty buffer should be true");

        //              0123456 789012345678901234567
        b = new Buffer("This \n    has 14 characters");
        //              123456 123456789012345678901
        check(b.get() == 'T', "First get should return the first char");
        check(b.get() == 'h', "Second get should return the second char");
        b.skipBlanks();
        check(b.get() == 'i', "Third get should return the third char");
        b.get();
        b.skipBlanks();
        check(b.get() == 'h', "skipBlanks should skip whitespace");
        check(b.getId().equals("as"), "getId() should return an id");
        check(b.getId().equals(""), "getId should return empty string if no id");
        //System.out.println("gn: '" +b.getNumber() +"'");
        check(b.getNumber().equals("14"), "getNo should return an number");
        check(b.getPos() == 16, "currentPos() should return the buffer position");
        check(b.columnNumber() == 11, "columnNumber() should return the col position");
        check(b.lineNumber() == 2, "lineNumber() should return the current position");
        check(b.getFileName().equals("Source string"), "Filename for string is correct");

        b = new Buffer("Here we go again = /= *8&^%$");

        check(b.getId().equals("Here"), "getId skips leading blanks");
        check(b.getId().equals("we"), "getId skips leading blanks");
        check(b.getId().equals("go"), "getId skips leading blanks");
        check(b.getId().equals("again"), "getId skips leading blanks");
        check(b.getOperator().equals("="), "getOperator obtains string");
        check(b.getOperator().equals("/="), "getOperator obtains string");
        check(b.getOperator().equals("*"), "getOperator obtains string");
        check(b.getNumber().equals("8"), "getNumber obtains string");
        check(b.getOperator().equals("&^%$"), "getOperator obtains string");
        check(b.getOperator().equals(""), "getOperator obtains string");

        b = new Buffer("   And\n    again");
        check(b.getToEoln().equals("   And"), "getToEoln() does not include newline");
        check(b.getToEoln().equals("    again"), "getToEoln() skips newline");

//		b = new Buffer("abc x  $543.79");
        b.setSource("abc x  $543.79");
        check(b.getToDelimiter("c").equals("ab"), "getToDelim does not include delim");

        check(b.getToDelimiter("$").equals(" x  "), "getToDelim does not include delim");
        //  ' x  '
        check(b.peek() == '5', "currentChar() should return the that would be fetched by get()");
        check(b.nextChar() == '4', "nextChar() should return the char that follows that which will be fetched by get()");
        check(b.size() == "abc x  $543.79".length(), "size() should return the number of chars in the buffer");
        try {
            FileWriter out = new FileWriter("temp");
            out.write("abc x  $543.79");
            out.close();

        } catch (IOException ex) {
            Logger.getLogger(Buffer.class.getName()).log(Level.SEVERE, null, ex);
        }
        FileReader in;
        try {
            in = new FileReader("temp");
            b.setSource(in, "temp");
        } catch (FileNotFoundException ex) {
            Logger.getLogger(Buffer.class.getName()).log(Level.SEVERE, null, ex);
        }

        check(b.getToDelimiter("c").equals("ab"), "getToDelim does not include delim");

        check(b.getToDelimiter("$").equals(" x  "), "getToDelim does not include delim");
        //  ' x  '
        check(b.peek() == '5', "currentChar() should return the that would be fetched by get()");
        check(b.nextChar() == '4', "nextChar() should return the char that follows that which will be fetched by get()");

    }
}
